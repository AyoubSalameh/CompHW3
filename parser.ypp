%{
    #include <iostream>
    #include "output.hpp"
    using namespace std;
    int yylex();
    extern int yylineno;
    void yyerror(const char*);
%}

%nonassoc VOID
%nonassoc INT
%nonassoc BYTE
%nonassoc BOOL
%nonassoc OVERRIDE

%nonassoc TRUE
%nonassoc FALSE
%nonassoc RETURN
%nonassoc IF

%nonassoc WHILE
%nonassoc BREAK
%nonassoc CONTINUE
%nonassoc SC
%nonassoc COMMA
%nonassoc ID
%nonassoc NUM
%nonassoc STRING
%nonassoc B

%right ASSIGN
%left OR
%left AND

%left EQUALITY
%left RELATION

%left PLUS_MINUS
%left MUL_DIV

%right NOT

%left LPAREN
%left RPAREN
%left LBRACE
%left RBRACE

%nonassoc ELSE

%%
Program: Funcs                                                                  {output::printProductionRule(1);}

Funcs: /*epsilon*/                                                              {output::printProductionRule(2);}
     | FuncDecl Funcs                                                           {output::printProductionRule(3);}
     ;

FuncDecl: OverRide RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE    {output::printProductionRule(4);}

OverRide: /*epsilon*/                                                           {$$ = new OverRide();}
        | OVERRIDE                                                              {$$ = new OverRude(true);}
        ;

RetType: Type                                                                   {$$ = new RetType(dynamic_cast<Type*>($1)->type);}
       | VOID                                                                   {$$ = new RetType("void");}
       ;

Formals: /*epsilon*/                                                            {$$ = new Formals();}
           | FormalsList                                                        {$$ = new Formals(dynamic_cast<FormalsList*>($1));}
       ;

FormalsList: FormalDecl                                                         {$$ = new FormalsList(dynamic_cast<FormalDecl*>($1));}
           | FormalDecl COMMA FormalsList                                       {$$ = new FormalsList(dynamic_cast<FormalDecl*>($1), dynamic_cast<FormalsList*>($3));}
           ;

FormalDecl: Type ID                                                             {$$ = new FormalDecl(dynamic_cast<Type*>($1), $2);}

Statements: Statement  {output::printProductionRule(14);}
          | Statements Statement    {output::printProductionRule(15);}
          ;
          
Statement: LBRACE Statements RBRACE    {output::printProductionRule(16);}
          | Type ID SC                  {output::printProductionRule(17);}
          | Type ID ASSIGN Exp SC       {output::printProductionRule(18);}
          | ID ASSIGN Exp SC            {output::printProductionRule(19);}
          | Call SC                     {output::printProductionRule(20);}
          | RETURN SC                   {output::printProductionRule(21);}
          | RETURN Exp SC               {output::printProductionRule(22);}
          | IF LPAREN Exp RPAREN Statement  {output::printProductionRule(23);}
          | IF LPAREN Exp RPAREN Statement ELSE Statement       {output::printProductionRule(24);}
          | WHILE LPAREN Exp RPAREN Statement       {output::printProductionRule(25);}
          | BREAK SC                    {output::printProductionRule(26);}
          | CONTINUE SC                 {output::printProductionRule(27);}
          ;
          
Call: ID LPAREN ExpList RPAREN      {output::printProductionRule(28);}
    | ID LPAREN RPAREN          {output::printProductionRule(29);}
    ;
    
ExpList: Exp       {output::printProductionRule(30);}
       | Exp COMMA ExpList      {output::printProductionRule(31);}
       ;
       
Type: INT                                                                       {$$ = new Type("int");}
    | BYTE                                                                      {$$ = new Type("byte");}
    | BOOL                                                                      {$$ = new Type("bool");}
    ;
    
Exp: LPAREN Exp RPAREN                                                          {$$ = new Exp(dynamic_cast<Exp*>($2));}
    | Exp PLUS_MINUS Exp                                                        {$$ = new Exp(dynamic_cast<Exp*>($1), $2, dynamic_cast<Exp*>($3));}
    | Exp MUL_DIV Exp                                                           {$$ = new Exp(dynamic_cast<Exp*>($1), $2, dynamic_cast<Exp*>($3));}
    | ID                    {output::printProductionRule(37);}
    | Call              {output::printProductionRule(38);}
    | NUM                                                                       {$$ = new Exp($1, "int");}
    | NUM B                                                                     {$$ = new Exp($1, $2);}
    | STRING                                                                    {$$ = new Exp($1, "string");}
    | TRUE                                                                      {$$ = new Exp($1, "bool");}
    | FALSE                                                                     {$$ = new Exp($1, "bool");}
    | NOT Exp                                                                   {$$ = new Exp($1, dynamic_cast<Exp*>($2));}
    | Exp AND Exp                                                               {$$ = new Exp(dynamic_cast<Exp*>($1), $2, dynamic_cast<Exp*>($3));}
    | Exp OR Exp                                                                {$$ = new Exp(dynamic_cast<Exp*>($1), $2, dynamic_cast<Exp*>($3));}
    | Exp EQUALITY Exp                                                          {$$ = new Exp(dynamic_cast<Exp*>($1), $2, dynamic_cast<Exp*>($3));}
    | Exp RELATION Exp                                                          {$$ = new Exp(dynamic_cast<Exp*>($1), $2, dynamic_cast<Exp*>($3));}
    | LPAREN Type RPAREN Exp                                                    {$$ = new Exp(dynamic_cast<Type*>($2), dynamic_cast<Exp*>($4));}
    ;

%%

void yyerror(const char*) {
    output::errorSyn(yylineno);
    exit(0);
}

int main(){
    return yyparse();
}